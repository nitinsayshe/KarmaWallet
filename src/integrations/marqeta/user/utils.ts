import { closeMarqetaAccount, getMarqetaUser, updateMarqetaUser } from '.';
import { generateRandomPasswordString } from '../../../lib/misc';
import { IUserDocument, UserModel } from '../../../models/user';
import { IVisitorDocument, VisitorModel } from '../../../models/visitor';
import { removeUserFromDebitCardHoldersList } from '../../../services/marketingSubscription/utils';
import { register, checkIfUserPassedInternalKycAndUpdateMarqetaStatus, formatMarqetaClosedEmail } from '../../../services/user';
import { isUserDocument } from '../../../services/user/utils';
import { IMarqetaUserStatus, MarqetaUserModel, IMarqetaUserTransitionsEvent, IMarqetaKycState } from './types';

export const createNewUserFromMarqetaWebhook = async (visitor: IVisitorDocument) => {
  const { user } = await register({
    name: `${visitor.integrations.marqeta.first_name} ${visitor.integrations.marqeta.last_name}`,
    password: generateRandomPasswordString(14),
    visitorId: visitor._id.toString(),
    isAutoGenerated: true,
  });

  user.integrations.marqeta = visitor.integrations.marqeta;
  await user.save();
  return user;
};

export const handleMarqetaUserActiveTransition = async (user: IUserDocument) => {
  user.integrations.marqeta.kycResult = { status: IMarqetaKycState.success, codes: [] };
  user.integrations.marqeta.status = IMarqetaUserStatus.ACTIVE;
  const savedUser = await user.save();
  return savedUser;
};

export const handleMarqetaVisitorActiveTransition = async (visitor: IVisitorDocument) => {
  visitor.integrations.marqeta.kycResult = { status: IMarqetaKycState.success, codes: [] };
  visitor.integrations.marqeta.status = IMarqetaUserStatus.ACTIVE;
  const savedVisitor = await visitor.save();
  return savedVisitor;
};

const updateMarqetaUserEmail = async (userToken: string, email: string) => {
  try {
    await updateMarqetaUser(userToken, { email });
  } catch (error) {
    console.log('Error updating Marqeta user email', error);
  }
};

export const setClosedEmailAndStatusAndRemoveMarqetaIntegration = async (
  entity: IUserDocument | IVisitorDocument,
): Promise<IUserDocument | IVisitorDocument> => {
  try {
    console.log('///// Closing Marqeta Account ///// for user with email:', entity?.integrations?.marqeta?.email);
    if (entity?.integrations?.marqeta?.email.includes('+closed')) {
      console.log('Marqeta email already closed, skipping');
      return entity;
    }

    const closedEmail = formatMarqetaClosedEmail(entity?.integrations?.marqeta?.email);
    if (!closedEmail) throw new Error('No email found in marqeta integration');
    await updateMarqetaUserEmail(entity?.integrations?.marqeta?.userToken, closedEmail);
    await closeMarqetaAccount({ data: entity, type: isUserDocument(entity) ? 'user' : 'visitor' });
    await removeUserFromDebitCardHoldersList(entity);
    // add in code to update the user in the database

    // remove the marqeta itegration from the user object
    entity.integrations.marqeta = undefined;
    return await entity.save();
  } catch (error) {
    console.log('Error updating Marqeta user email', error);
  }
};

// if the status is closed, add '+closed' to this email in marqeta
export const setClosedMarqetaAccountState = async (
  user: IVisitorDocument | IUserDocument,
  userTransition: Partial<IMarqetaUserTransitionsEvent>,
): Promise<void> => {
  if (!user || !userTransition?.status || userTransition?.status !== IMarqetaUserStatus.CLOSED) {
    return;
  }
  await setClosedEmailAndStatusAndRemoveMarqetaIntegration(user);
};

// Existing User withe the Marqeta Integration Already Saved
export const updateExistingUserFromMarqetaWebhook = async (
  user: IUserDocument,
  currentMarqetaUserData: MarqetaUserModel,
  webhookData: IMarqetaUserTransitionsEvent,
) => {
  user.integrations.marqeta.status = currentMarqetaUserData.status;
  if (webhookData.status === IMarqetaUserStatus.CLOSED) {
    user.karmaMembership.status = 'cancelled';
    await user.save();
    await setClosedMarqetaAccountState(user, currentMarqetaUserData);
  }

  // If reason attribute is missing in userTransition(webhook data) then populate the reson based on reson_code
  if (webhookData.status === currentMarqetaUserData.status) {
    const { reason, reason_code: reasonCode } = webhookData;
    user.integrations.marqeta.reason = !!reason ? reason : '';
    user.integrations.marqeta.reason_code = !!reasonCode ? reasonCode : '';
    await user.save();
  }

  if (currentMarqetaUserData.status === IMarqetaUserStatus.ACTIVE) {
    await handleMarqetaUserActiveTransition(user);
  }
};

export const handleMarqetaUserTransitionWebhook = async (userTransition: IMarqetaUserTransitionsEvent) => {
  const existingUser = await UserModel.findOne({ 'integrations.marqeta.userToken': userTransition?.user_token });
  const visitor = await VisitorModel.findOne({ 'integrations.marqeta.userToken': userTransition?.user_token });
  const foundEntity = !!existingUser ? existingUser : visitor;

  if (!foundEntity) {
    console.log('[+] User or Visitor with matching token not found');
    return;
  }

  // grab the user data from Marqeta directly since webhooks can come in out of order
  const currentMarqetaUserData = await getMarqetaUser(userTransition?.user_token);

  if (!currentMarqetaUserData) {
    console.log('[+] Error getting most up to date user information from Marqeta');
  }

  if (currentMarqetaUserData?.status !== IMarqetaUserStatus.CLOSED) {
    const userPassedInternalKyc = await checkIfUserPassedInternalKycAndUpdateMarqetaStatus(foundEntity);

    if (!userPassedInternalKyc) {
      console.log('[+] User or Visitor did not pass internal KYC, do not do anything else');
      return;
    }
  }

  if (!!existingUser?._id && (existingUser?.integrations?.marqeta?.status !== currentMarqetaUserData?.status || currentMarqetaUserData?.status === IMarqetaUserStatus.ACTIVE)) {
    await updateExistingUserFromMarqetaWebhook(existingUser, currentMarqetaUserData, userTransition);
  }
  // EXISTING VISITOR, Marqeta integration is saved on the visitor object,
  if (!!visitor?._id && !existingUser?._id) {
    if (currentMarqetaUserData?.status === IMarqetaUserStatus.ACTIVE) {
      await handleMarqetaVisitorActiveTransition(visitor);
    }
    await setClosedMarqetaAccountState(visitor, currentMarqetaUserData);
  }
};
